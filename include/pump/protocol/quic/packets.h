
/*
 * Copyright (C) 2015-2018 ZhengHaiTao <ming8ren@163.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef pump_protocol_quic_packets_h
#define pump_protocol_quic_packets_h

#include <string>
#include <vector>

#include "pump/types.h"

namespace pump {
namespace protocol {
namespace quic {

    typedef uint8_t long_packet_type;
    const static long_packet_type LONG_INITIAL_PACKET   = 0x00;
    const static long_packet_type LONG_0RTT_PACKET      = 0x01;
    const static long_packet_type LONG_HANDSHAKE_PACKET = 0x02;
    const static long_packet_type LONG_RETRY_PACKET     = 0x03;

    struct long_packet_header {
        // First byte.
        uint8_t fb;

        // The field represents the version of QUIC.
        uint32_t version;

        // The byte following the version contains the length in bytes of the Destination Connection ID field 
        // that follows it. This length is encoded as an 8-bit unsigned integer. In QUIC version 1, this value 
        // MUST NOT exceed 20 bytes. Endpoints that receive a version 1 long header with a value larger than 20 
        // MUST drop the packet. In order to properly form a Version Negotiation packet, servers SHOULD be able 
        // to read longer connection IDs from other QUIC versions.
        //uint8 des_connection_id_length;

        // The Destination Connection ID field follows the Destination Connection ID Length field, which indicates 
        // the length of this field.
        std::string des_connection_id;

        // The byte following the Destination Connection ID contains the length in bytes of the Source Connection 
        // ID field that follows it. This length is encoded as an 8-bit unsigned integer. In QUIC version 1, this 
        // value MUST NOT exceed 20 bytes. Endpoints that receive a version 1 long header with a value larger than 
        // 20 MUST drop the packet. In order to properly form a Version Negotiation packet, servers SHOULD be able 
        // to read longer connection IDs from other QUIC versions.
        //uint8 src_connection_id_length;

        // The Source Connection ID field follows the Source Connection ID Length field, which indicates the length 
        // of this field.
        std::string src_connection_id;
    };

    /*
    * A Version Negotiation packet is inherently not version specific. Upon receipt by a client, it will be 
    * identified as a Version Negotiation packet based on the Version field having a value of 0. 
    * 
    * The Version Negotiation packet is a response to a client packet that contains a version that is not 
    * supported by the server. It is only sent by servers. 
    * 
    * The Version field of a Version Negotiation packet MUST be set to 0x00000000.
    * 
    * The server MUST include the value from the Source Connection ID field of the packet it receives in the 
    * Destination Connection ID field. The value for Source Connection ID MUST be copied from the Destination 
    * Connection ID of the received packet, which is initially randomly selected by a client. Echoing both 
    * connection IDs gives clients some assurance that the server received the packet and that the Version 
    * Negotiation packet was not generated by an entity that did not observe the Initial packet.
    * 
    * Future versions of QUIC could have different requirements for the lengths of connection IDs. In particular, 
    * connection IDs might have a smaller minimum length or a greater maximum length. Version-specific rules for 
    * the connection ID therefore MUST NOT influence a decision about whether to send a Version Negotiation 
    * packet.
    * 
    * The remainder of the Version Negotiation packet is a list of 32-bit versions that the server supports.
    * 
    * A Version Negotiation packet is not acknowledged. It is only sent in response to a packet that indicates 
    * an unsupported version.
    * 
    * The Version Negotiation packet does not include the Packet Number and Length fields present in other 
    * packets that use the long header form. Consequently, a Version Negotiation packet consumes an entire UDP 
    * datagram.
    * 
    * A server MUST NOT send more than one Version Negotiation packet in response to a single UDP datagram.
    */
    struct version_negotiation_packet {
        // First byte format:
            // Header Form (1) = 1
            // Fixed Bit (1) = 0
            // Unused (6)
        // Version = 0
        long_packet_header header;

        // The field represents supported versions list.    
        std::vector<uint32_t> supported_versions;
    };

    /*
    * An Initial packet uses long headers with a type value of 0x00. It carries the first CRYPTO frames sent by 
    * the client and server to perform key exchange, and it carries ACK frames in either direction.
    * 
    * The payload of an Initial packet includes a CRYPTO frame (or frames) containing a cryptographic handshake message, 
    * ACK frames, or both. PING, PADDING, and CONNECTION_CLOSE frames of type 0x1c are also permitted. An endpoint that 
    * receives an Initial packet containing other frames can either discard the packet as spurious or treat it as a 
    * connection error.
    * 
    * The first packet sent by a client always includes a CRYPTO frame that contains the start or all of the first 
    * cryptographic handshake message. The first CRYPTO frame sent always begins at an offset of 0.
    * 
    * Note that if the server sends a TLS HelloRetryRequest (see Section 4.7 of [QUIC-TLS]), the client will send another 
    * series of Initial packets. These Initial packets will continue the cryptographic handshake and will contain CRYPTO 
    * frames starting at an offset matching the size of the CRYPTO frames sent in the first flight of Initial packets.
    */
    struct initial_packet {
        // First byte format:
            // Header Form (1) = 1
            // Fixed Bit (1) = 1
            // Long Packet Type (2) = 0
            // Reserved Bits (2)
            // Packet Number Length (2)
        long_packet_header header;

        // A variable-length integer specifying the length of the Token field, in bytes. 
        // This value is 0 if no token is present. Initial packets sent by the server 
        // MUST set the Token Length field to 0; clients that receive an Initial packet 
        // with a non-zero Token Length field MUST either discard the packet or generate 
        // a connection error of type PROTOCOL_VIOLATION.
        uint32_t token_length;
        // The value of the token that was previously provided in a Retry packet or NEW_TOKEN frame.
        std::string token;

        // This is the length of the remainder of the packet (that is, the Packet Number and Payload fields) in bytes, 
        // encoded as a variable-length integer 
        uint32_t length;

        // This field is 1 to 4 bytes long. The packet number is protected using header protection. The length of the 
        // Packet Number field is encoded in the Packet Number Length bits of byte 0.
        uint32_t packet_number;

        // This is the payload of the packet -- containing a sequence of frames -- that is protected using packet protection.
        std::string packet_payload;
    };

    /*
    * A 0-RTT packet uses long headers with a type value of 0x01, followed by the Length and Packet Number fields. The 
    * first byte contains the Reserved and Packet Number Length bits. A 0-RTT packet is used to carry "early" data 
    * from the client to the server as part of the first flight, prior to handshake completion. As part of the TLS 
    * handshake, the server can accept or reject this early data.
    *
    * Packet numbers for 0-RTT protected packets use the same space as 1-RTT protected packets.
    * 
    * After a client receives a Retry packet, 0-RTT packets are likely to have been lost or discarded by the server. A 
    * client SHOULD attempt to resend data in 0-RTT packets after it sends a new Initial packet. New packet numbers 
    * MUST be used for any new packets that are sent, reusing packet numbers could compromise packet protection.
    * 
    * A client MUST NOT send 0-RTT packets once it starts processing 1-RTT packets from the server. This means that 
    * 0-RTT packets cannot contain any response to frames from 1-RTT packets. For instance, a client cannot send an ACK 
    * frame in a 0-RTT packet, because that can only acknowledge a 1-RTT packet. An acknowledgment for a 1-RTT packet 
    * MUST be carried in a 1-RTT packet.
    * 
    * A server SHOULD treat a violation of remembered limits as a connection error of an appropriate type (for 
    * instance, a FLOW_CONTROL_ERROR for exceeding stream data limits).
    */
    struct zero_rtt_packet {
        // First byte format:
            // Header Form (1) = 1
            // Fixed Bit (1) = 1
            // Long Packet Type (2) = 1
            // Reserved Bits (2)
            // Packet Number Length (2)
        long_packet_header header;

        // This is the length of the remainder of the packet (that is, the Packet Number and Payload fields) in bytes, 
        // encoded as a variable-length integer 
        uint32_t length;

        // This field is 1 to 4 bytes long. The packet number is protected using header protection. The length of the 
        // Packet Number field is encoded in the Packet Number Length bits of byte 0.
        uint32_t packet_number;

        // This is the payload of the packet -- containing a sequence of frames -- that is protected using packet protection.
        std::string packet_payload;
    };

    /*
    * A Handshake packet uses long headers with a type value of 0x02, followed by the Length and Packet Number fields. 
    * The first byte contains the Reserved and Packet Number Length bits. It is used to carry cryptographic handshake 
    * messages and acknowledgments from the server and client.
    * 
    * Once a client has received a Handshake packet from a server, it uses Handshake packets to send subsequent 
    * cryptographic handshake messages and acknowledgments to the server.
    * 
    * Handshake packets have their own packet number space, and thus the first Handshake packet sent by a server 
    * contains a packet number of 0.
    * 
    * The payload of this packet contains CRYPTO frames and could contain PING, PADDING, or ACK frames. Handshake 
    * packets MAY contain CONNECTION_CLOSE frames of type 0x1c. Endpoints MUST treat receipt of Handshake packets with 
    * other frames as a connection error of type PROTOCOL_VIOLATION.
    * 
    * Like Initial packets, data in CRYPTO frames for Handshake packets is discarded -- and no longer retransmitted -- 
    * when Handshake protection keys are discarded.
    */
    struct handshake_packet {
        // First byte format:
            // Header Form (1) = 1
            // Fixed Bit (1) = 1
            // Long Packet Type (2) = 2
            // Reserved Bits (2)
            // Packet Number Length (2)
        long_packet_header header;

        // This is the length of the remainder of the packet (that is, the Packet Number and Payload fields) in bytes, 
        // encoded as a variable-length integer 
        uint32_t length;

        // This field is 1 to 4 bytes long. The packet number is protected using header protection. The length of the 
        // Packet Number field is encoded in the Packet Number Length bits of byte 0.
        uint32_t packet_number;

        // This is the payload of the packet -- containing a sequence of frames -- that is protected using packet protection.
        std::string packet_payload;
    };

    /*
    * A Retry packet uses a long packet header with a type value of 0x03. It carries an address validation token created 
    * by the server. It is used by a server that wishes to perform a retry.
    * 
    * A server MAY send Retry packets in response to Initial and 0-RTT packets. A server can either discard or buffer 
    * 0-RTT packets that it receives. A server can send multiple Retry packets as it receives Initial or 0-RTT packets. 
    * A server MUST NOT send more than one Retry packet in response to a single UDP datagram.
    * 
    * A client MUST accept and process at most one Retry packet for each connection attempt. After the client has received 
    * and processed an Initial or Retry packet from the server, it MUST discard any subsequent Retry packets that it 
    * receives.
    * 
    * Clients MUST discard Retry packets that have a Retry Integrity Tag that cannot be validated. This diminishes an 
    * attacker's ability to inject a Retry packet and protects against accidental corruption of Retry packets. A client 
    * MUST discard a Retry packet with a zero-length Retry Token field.
    * 
    * The client responds to a Retry packet with an Initial packet that includes the provided Retry token to continue 
    * connection establishment.
    * 
    * A client sets the Destination Connection ID field of this Initial packet to the value from the Source Connection ID 
    * field in the Retry packet. Changing the Destination Connection ID field also results in a change to the keys used to 
    * protect the Initial packet. It also sets the Token field to the token provided in the Retry packet. The client MUST 
    * NOT change the Source Connection ID because the server could include the connection ID as part of its token 
    * validation logic.
    * 
    * A Retry packet does not include a packet number and cannot be explicitly acknowledged by a client.
    */
    struct retry_packet {
        // First byte format:
            // Header Form (1) = 1
            // Fixed Bit (1) = 1
            // Long Packet Type (2) = 3
            // Unused (4)
        long_packet_header header;

        // An opaque token that the server can use to validate the client's address.
        std::string retry_token;
        
        // Defined in Section 5.8 ("Retry Packet Integrity") of [QUIC-TLS].
        uint8_t retry_integrity_tag;
    };

    struct short_packet_header {
        // First byte.
        uint8_t fb;

        // The field represents the length of the destination connection id.
        //uint8 des_conntion_id_length;
        // The field represents destination connection id, max length is 20 bytes.
        std::string des_connection_id;
    };

    /*
    * A 1-RTT packet uses a short packet header. It is used after the version and 1-RTT keys are negotiated.
    */
    struct one_rtt_packet {
        // First byte format:
            // Header Form (1) = 0
            // Fixed Bit (1) = 1
            // Spin Bit (1)
            // Reserved Bits (2)
            // Key Phase (1)
            // Packet Number Length (2)
        short_packet_header header;
        
        // The field represents the pakcet number.
        uint32_t packet_number;
        // The field represents the pakcet payload.
        std::string packet_payload;
    };

    bool is_long_packet(uint8_t b);

    bool is_version_negotiation_packet(uint8_t b);

    uint8_t parse_packet_number_length(uint8_t b);

    uint8_t parse_long_packet_type(uint8_t b);

    uint8_t parse_short_packet_spin_bit(uint8_t b);

    uint8_t parse_short_packet_key_phase(uint8_t b);

}
}
}

#endif